Docker / MailHog dev setup for the team

Goal
- Provide a reproducible Docker setup so team members can run the HotelBookingApp with a local MariaDB and MailHog (SMTP catcher) exactly like you do.

Prerequisites
- Docker Desktop installed and running (Windows)
- Docker Compose v1 or v2 (bundled with Docker Desktop)
- (Optional) Maven & JDK if building locally before containerization

Overview
- We provide a multi-stage Dockerfile to build the Spring Boot jar and run it in a slim JDK image.
- `docker-compose.yml` starts three services: `app` (your Spring Boot app), `db` (MariaDB) and `mailhog` (SMTP catcher + web UI).
- App communicates with `mailhog` via SMTP (host: `mailhog`, port: `1025`). MailHog web UI is exposed on port `8025`.

Files / Snippets (copy into the project root)

1) Dockerfile (multi-stage build)

```
# Stage 1: build
FROM maven:3.8.8-eclipse-temurin-17 AS build
WORKDIR /workspace
COPY pom.xml ./
COPY src ./src
RUN mvn -B -DskipTests package

# Stage 2: runtime
FROM eclipse-temurin:17-jdk
WORKDIR /app
# Adjust JAR name if different
COPY --from=build /workspace/target/HotelBookingApp-1.0.0.jar ./app.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/app/app.jar"]
```

Notes:
- If your final JAR name differs, update the `COPY` path.
- You can build the jar locally with `mvn -DskipTests package` and then `docker build` using a simpler Dockerfile that copies the produced JAR.

2) docker-compose.yml (dev)

```
version: '3.8'
services:
  db:
    image: mariadb:10.11
    environment:
      - MYSQL_DATABASE=hotelbooking
      - MYSQL_USER=hotel
      - MYSQL_PASSWORD=hotelpass
      - MYSQL_ROOT_PASSWORD=rootpass
    volumes:
      - db_data:/var/lib/mysql
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5

  mailhog:
    image: mailhog/mailhog
    ports:
      - "1025:1025"   # SMTP
      - "8025:8025"   # Web UI

  app:
    build: .
    image: hotelbookingapp:dev
    depends_on:
      db:
        condition: service_healthy
      mailhog:
        condition: service_started
    environment:
      - SPRING_DATASOURCE_URL=jdbc:mariadb://db:3306/hotelbooking
      - SPRING_DATASOURCE_USERNAME=hotel
      - SPRING_DATASOURCE_PASSWORD=hotelpass
      - SPRING_MAIL_HOST=mailhog
      - SPRING_MAIL_PORT=1025
      - APP_MAIL_FROM=dev@local.test
      - SPRING_JPA_HIBERNATE_DDL_AUTO=update
    ports:
      - "8080:8080"
    restart: unless-stopped

volumes:
  db_data:
```

Important notes about the compose file:
- `db` uses credentials `hotel` / `hotelpass`. Match these in the `SPRING_*` env values.
- `mailhog` service name is `mailhog`; the app uses that as SMTP host so containers talk via Docker network.
- `SPRING_JPA_HIBERNATE_DDL_AUTO=update` lets Hibernate create/update tables from entities. If you rely on `schema.sql`/`data.sql`, keep `spring.sql.init.mode` settings accordingly.

3) .env (optional)
- You can create a `.env` file next to `docker-compose.yml` and reference variables in `docker-compose.yml` (easier for secrets).

How to build & run (PowerShell)

- Build and run with Docker Compose (builds the `app` image using the Dockerfile):

```powershell
cd 'C:\Users\vikgo\Desktop\Projekt\repogit\Fallstudie_Hotel\Fallstudie_Hotel'
docker compose up --build -d
```

- Check logs for all services:

```powershell
docker compose logs -f
# or per service
docker compose logs -f app
```

- Stop and remove containers:

```powershell
docker compose down
```

Testing / Using MailHog
- MailHog web UI: http://localhost:8025
- SMTP port (for app): 1025 (mapped to `mailhog` service inside Docker Network)
- To inspect messages via API (from host):

```powershell
Invoke-RestMethod http://localhost:8025/api/v2/messages | ConvertTo-Json -Depth 5
```

If mails are not received:
- Confirm the app's SMTP config points to `mailhog:1025` (in compose we set `SPRING_MAIL_HOST=mailhog`).
- Check `docker compose logs app` for errors sending mail.
- Confirm MailHog is up (`docker compose ps` or view port 8025).

Database considerations (dev team)
- The compose includes MariaDB; first run it will initialize the DB.
- If you use `schema.sql` and `data.sql` (project currently has those), Spring Boot's `spring.sql.init.*` properties will apply. Be careful: mixing `schema.sql` with Hibernate `update` can cause conflicts.
- Recommended for team: either rely on Hibernate `ddl-auto=update` (fast dev) OR use migrations (Flyway) + versioned SQL. For collaborative work Flyway is preferred.

Alternative: run MailHog alone (no compose)
- If you already run the app locally (not in Docker) and just want MailHog:

```powershell
docker run -d --name mailhog -p 1025:1025 -p 8025:8025 mailhog/mailhog
```

Then set in `application.properties` (or env):
```
spring.mail.host=localhost
spring.mail.port=1025
app.mail.from=dev@local.test
```

Troubleshooting tips
- If DB schema errors occur at startup (FK errors, syntax error), try:
  - Inspect `schema.sql` / `data.sql` for syntax issues (we fixed one earlier).
  - Temporarily disable script init: `spring.sql.init.mode=never` and allow Hibernate to create tables.
  - Use `docker compose down -v` to remove volumes and start with a fresh DB.
- If the app image build fails due to memory/timeouts, try building the jar locally with `mvn -DskipTests package` and use a simpler runtime Dockerfile that only copies the jar.

Recommended quick workflow for team
1. Clone the repo
2. Make sure Docker Desktop is running
3. From project root run (PowerShell):

```powershell
cd 'C:\Users\vikgo\Desktop\Projekt\repogit\Fallstudie_Hotel\Fallstudie_Hotel'
docker compose up --build -d
```
4. Open `http://localhost:8025` to view emails, `http://localhost:8080` to open the app.

Questions / Next steps I can do for you
- Create `docker-compose.yml` and `Dockerfile` in the repo (I can add them directly).
- Add a small `.env.example` with DB creds and `APP_MAIL_FROM` to the repo.
- Add a short README section describing the Docker dev flow.

If you want, I can now create `Dockerfile`, `docker-compose.yml` and `.env.example` in the repository and mark the todo as completed â€” tell me to proceed and I will add them and run a quick local verification (log check).