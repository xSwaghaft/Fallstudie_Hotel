package com.hotel.booking.service;

import com.hotel.booking.entity.Booking;
import com.hotel.booking.entity.BookingExtra;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Service class providing reporting and analytics functionality.
 * <p>
 * This service aggregates booking-related data and calculates
 * key performance indicators (KPIs) such as revenue, trends,
 * average stay duration, and popularity metrics for a given period.
 * It is primarily used by the Reports & Analytics view.
 * </p>
 *
 * @author Matthias Lohr
 */
@Service
@Transactional
public class ReportService {

    private final BookingService bookingService;

    public ReportService(BookingService bookingService) {
        this.bookingService = bookingService;
    }

    /**
     * Calculates the total revenue generated by all bookings within a given period.
     * <p>
     * The total revenue is computed by summing up the total price of each booking
     * and returning the formatted result including the currency symbol.
     * </p>
     */
    public String getTotalRevenueInPeriod(LocalDate from, LocalDate to) {
        BigDecimal total = bookingService.getAllBookingsInPeriod(from, to)
            .stream()
            .map(Booking::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add); //ZERO is identity(start), BigDecimal.add gets each value added

            return String.format("%.2f €", total);
    }

    /**
     * Determines the most frequently booked extra within a given period.
     * <p>
     * All booking extras are flattened into a single stream and grouped by name
     * to identify the most popular extra based on occurrence count.
     * </p>
     */
    public String getMostPopularExtraInPeriod(LocalDate from, LocalDate to) {
        List<Booking> bookings = bookingService.getAllBookingsInPeriod(from, to);

        // Map<Name, Count>
        Map<String, Long> countMap = bookings.stream()
        .filter(b -> b.getExtras() != null)                  
        .flatMap(b -> b.getExtras().stream())                // Flatten all extras from all bookings in their own stream
        .map(BookingExtra::getName)                          // Only count name
        .collect(Collectors.groupingBy(name -> name, Collectors.counting()));

        // no extra -> return 
        if (countMap.isEmpty()) {
            return "None";
        }

        // Find the most popular extra based on frequency
        return countMap.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("None");
    }

    public String getMostPopularExtraLastPeriod(LocalDate from, LocalDate to) {
        String extra = getMostPopularExtraInPeriod(from.minusMonths(1), to.minusMonths(1));
        return "Last Period: " + extra;
    }

    /**
     * Calculates the average stay duration (in days) for bookings within a given period.
     * <p>
     * The duration is computed using {@link ChronoUnit#DAYS} between
     * check-in and check-out dates and returned as a formatted string.
     * </p>
     */
    public String getAvgStayDurationInPeriod(LocalDate from, LocalDate to) {
        List<Booking> bookings = bookingService.getAllBookingsInPeriod(from, to);

        if (bookings.isEmpty()) {
            return "0.00";
        }
        double avg = bookings.stream()
            .mapToLong(b -> ChronoUnit.DAYS.between(b.getCheckInDate(), b.getCheckOutDate()))
            .average()
            .orElse(0.0);

        return String.format("%.2f days", avg);
    }


    /**
     * Determines the most frequently booked room category within a given period.
     * <p>
     * Room categories are grouped by name and evaluated based on booking count
     * to identify the most popular category.
     * </p>
     */
    public String getTopCategoryInPeriod(LocalDate from, LocalDate to) {
        List<Booking> bookings = bookingService.getAllBookingsInPeriod(from, to);
        if (bookings.isEmpty()) {
            return "None";
        }
        // Map<Kategorie-Name, Anzahl> is stored into the map using a stream
        Map<String, Long> countMap = bookings.stream()
            .filter(b -> b.getRoomCategory() != null)
            .map(b -> b.getRoomCategory().getName())
            .collect(
                Collectors.groupingBy(name -> name, Collectors.counting())); //Groups the entries by name with count as value
        return countMap.entrySet().stream()
            .max(Map.Entry.comparingByValue()) //Get the entry with the highest number as the value
            .map(Map.Entry::getKey) //Retrieves the corresponding category name or 'None' since max is optional
            .orElse("None");
    }

    public String getMostPopularCategoryLastPeriod(LocalDate from, LocalDate to) {
        String category = getTopCategoryInPeriod(from.minusMonths(1), to.minusMonths(1));
        return "Last Period: " + category;
    }

    /**
     * Calculates the average revenue per booking within a given period.
     * <p>
     * The average is computed based on the total price of each booking
     * and returned as a formatted monetary value.
     * </p>
     */
    public String getAvgRevenuePerBookingInPeriod(LocalDate from, LocalDate to) {
                List<Booking> bookings = bookingService.getAllBookingsInPeriod(from, to);
        if (bookings.isEmpty()) {
            return "0.00 €";
        }
        double avg = bookings.stream()
            .map(Booking::getTotalPrice)
            .filter(price -> price != null)
            .mapToDouble(BigDecimal::doubleValue) //Zu double machen, um average anzuwenden zu können
            .average() //Liefert ein OptionalDouble, daher orElse
            .orElse(0.00);
        return String.format("%.2f €", avg);
    }

    //------------------Trend-String and Trend-boolean methods for all numeric KPIs-------------

    public String getBookingTrendString(LocalDate startDate, LocalDate endDate) {
        int thisPeriod = bookingService.getNumberOfBookingsInPeriod(startDate, endDate);
        int comparisonPeriod = bookingService.getNumberOfBookingsInPeriod(
            startDate.minusMonths(1), endDate.minusMonths(1));
        
        return createTrendString(thisPeriod, comparisonPeriod);
    }

    public boolean getBookingTrendPositive(LocalDate startDate, LocalDate endDate) {
        int thisPeriod = bookingService.getNumberOfBookingsInPeriod(startDate, endDate);
        int comparisonPeriod = bookingService.getNumberOfBookingsInPeriod(
            startDate.minusMonths(1), endDate.minusMonths(1));
        return thisPeriod > comparisonPeriod;
    }

    public String getAvgStayTrendString(LocalDate startDate, LocalDate endDate) {
        double thisPeriod = getAvgStayDurationValue(startDate, endDate);
        double comparisonPeriod = getAvgStayDurationValue(startDate.minusMonths(1), endDate.minusMonths(1));
        return createTrendString(thisPeriod, comparisonPeriod);
    }

    public boolean getAvgStayTrendPositive(LocalDate startDate, LocalDate endDate) {
        double thisPeriod = getAvgStayDurationValue(startDate, endDate);
        double comparisonPeriod = getAvgStayDurationValue(startDate.minusMonths(1), endDate.minusMonths(1));
        return thisPeriod > comparisonPeriod;
    }

    public String getAvgRevenueTrendString(LocalDate startDate, LocalDate endDate) {
        double thisPeriod = getAvgRevenueValue(startDate, endDate);
        double comparisonPeriod = getAvgRevenueValue(startDate.minusMonths(1), endDate.minusMonths(1));
        return createTrendString(thisPeriod, comparisonPeriod);
    }

    public boolean getAvgRevenueTrendPositive(LocalDate startDate, LocalDate endDate) {
        double thisPeriod = getAvgRevenueValue(startDate, endDate);
        double comparisonPeriod = getAvgRevenueValue(startDate.minusMonths(1), endDate.minusMonths(1));
        return thisPeriod > comparisonPeriod;
    }

    public String getTotalRevenueTrendString(LocalDate startDate, LocalDate endDate) {
        double thisPeriod = getTotalRevenueValue(startDate, endDate);
        double comparisonPeriod = getTotalRevenueValue(startDate.minusMonths(1), endDate.minusMonths(1));
        return createTrendString(thisPeriod, comparisonPeriod);
    }

    public boolean getTotalRevenueTrendPositive(LocalDate startDate, LocalDate endDate) {
        double thisPeriod = getTotalRevenueValue(startDate, endDate);
        double comparisonPeriod = getTotalRevenueValue(startDate.minusMonths(1), endDate.minusMonths(1));
        return thisPeriod > comparisonPeriod;
    }

    // Helper method for the value (no formatting)
    private double getAvgStayDurationValue(LocalDate from, LocalDate to) {
        List<Booking> bookings = bookingService.getAllBookingsInPeriod(from, to);
        if (bookings.isEmpty()) return 0.0;
        return bookings.stream()
            .mapToLong(b -> ChronoUnit.DAYS.between(b.getCheckInDate(), b.getCheckOutDate()))
            .average()
            .orElse(0.0);
    }

    private double getAvgRevenueValue(LocalDate from, LocalDate to) {
        List<Booking> bookings = bookingService.getAllBookingsInPeriod(from, to);
        if (bookings.isEmpty()) return 0.0;
        return bookings.stream()
            .map(Booking::getTotalPrice)
            .filter(price -> price != null)
            .mapToDouble(BigDecimal::doubleValue)
            .average()
            .orElse(0.0);
    }

    private double getTotalRevenueValue(LocalDate from, LocalDate to) {
        List<Booking> bookings = bookingService.getAllBookingsInPeriod(from, to);
        if (bookings.isEmpty()) return 0.0;
        return bookings.stream()
            .map(Booking::getTotalPrice)
            .filter(price -> price != null)
            .mapToDouble(BigDecimal::doubleValue)
            .sum();
    }

    /**
     * Creates a human-readable trend string comparing two numeric values.
     * <p>
     * The trend is expressed as a percentage difference relative to the comparison period.
     * Special cases such as missing comparison data are handled explicitly.
     * </p>
     */
    public String createTrendString(double thisPeriod, double comparisonPeriod) {

        String trendString;
    
        // No bookings in comparison period (or this)
        if (comparisonPeriod == 0) {
            if (thisPeriod > 0) {
                trendString = "No Records in comparison period";
            } else {
                trendString = "0% from last period"; 
            }
        } else {
            // Calculate the percentage change
            double difference = thisPeriod - comparisonPeriod;
            double percentage = (difference / comparisonPeriod) * 100;
            
            // DecimalFormat for formatting
            // Set locale to US for dot as separator
            DecimalFormatSymbols symbol = new DecimalFormatSymbols(Locale.US);
            // Pattern for positive and negative numbers
            DecimalFormat df = new DecimalFormat("+#0.0;-#0.0", symbol);
            
            // Format the value and append the rest of the string
            String formattedPercentage = df.format(percentage);
            trendString = formattedPercentage + "% from last period";
        }

        return trendString;
    }
}
